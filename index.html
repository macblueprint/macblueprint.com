import React, { useState, useEffect } from 'react'

// TicTacToe_AppleStyle.jsx
// Single-file React component, styled with Tailwind (Apple-like minimal glass UI)
// Features:
// - 1-player (vs CPU using Minimax) and 2-player local modes
// - Scoreboard, history, undo last move, reset
// - Smooth micro-interactions and accessible markup
// - Tailwind utility classes assumed available in the host project

export default function TicTacToeApple() {
  const emptyBoard = Array(9).fill(null)
  const [board, setBoard] = useState(emptyBoard)
  const [xIsNext, setXIsNext] = useState(true)
  const [mode, setMode] = useState('1P') // '1P' or '2P'
  const [scores, setScores] = useState({ X: 0, O: 0, ties: 0 })
  const [history, setHistory] = useState([]) // stack of {board, xIsNext}
  const winner = calculateWinner(board)
  const gameOver = winner || board.every(Boolean)

  // CPU plays as 'O' when mode === '1P' and it's O's turn
  useEffect(() => {
    if (mode === '1P' && !xIsNext && !gameOver) {
      const timer = setTimeout(() => {
        const move = findBestMove(board)
        if (move !== -1) handleMove(move)
      }, 300)
      return () => clearTimeout(timer)
    }
  }, [board, xIsNext, mode])

  function handleMove(index) {
    if (board[index] || gameOver) return
    const player = xIsNext ? 'X' : 'O'
    const newBoard = board.slice()
    newBoard[index] = player
    setHistory(h => [...h, { board: board.slice(), xIsNext }])
    setBoard(newBoard)
    setXIsNext(!xIsNext)
  }

  useEffect(() => {
    if (winner) {
      setScores(s => ({ ...s, [winner]: s[winner] + 1 }))
    } else if (board.every(Boolean)) {
      setScores(s => ({ ...s, ties: s.ties + 1 }))
    }
  // we want to update score only when game becomes finished
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [winner, board])

  function resetBoard(full = false) {
    setBoard(emptyBoard)
    setXIsNext(true)
    setHistory([])
    if (full) setScores({ X: 0, O: 0, ties: 0 })
  }

  function undo() {
    const last = history[history.length - 1]
    if (!last) return
    setBoard(last.board)
    setXIsNext(last.xIsNext)
    setHistory(h => h.slice(0, -1))
  }

  function toggleMode() {
    resetBoard()
    setMode(m => (m === '1P' ? '2P' : '1P'))
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-slate-900 to-slate-800 p-6">
      <div className="w-full max-w-xl">
        <div className="backdrop-blur-sm bg-white/6 border border-white/8 rounded-2xl p-6 shadow-2xl">
          <header className="flex items-center justify-between mb-4">
            <div>
              <h1 className="text-white text-2xl font-semibold tracking-tight">tic tac toe</h1>
              <p className="text-slate-300 text-sm">apple-ish • minimal • local play</p>
            </div>
            <div className="flex items-center gap-3">
              <button onClick={toggleMode} className="px-3 py-1 rounded-full border border-white/10 text-sm text-slate-200 hover:bg-white/3">{mode}</button>
              <button onClick={() => resetBoard(true)} className="px-3 py-1 rounded-full bg-white/5 text-sm text-slate-200 hover:bg-white/8">reset all</button>
            </div>
          </header>

          <main className="flex gap-6">
            <section className="flex-1">
              <div className="grid grid-cols-3 gap-3">
                {board.map((cell, i) => (
                  <button
                    key={i}
                    aria-label={`cell-${i}`}
                    onClick={() => handleMove(i)}
                    className={`aspect-square rounded-xl flex items-center justify-center text-3xl font-bold transition transform focus:outline-none focus:ring-2 focus:ring-white/20
                      ${cell ? 'cursor-default' : 'hover:scale-[1.02] hover:brightness-110'}
                      ${winner && isWinningCell(winner, board, i) ? 'ring-2 ring-offset-2 ring-white/30' : ''}
                      bg-gradient-to-b from-white/3 to-white/6 border border-white/6 text-white`}
                  >
                    <span className="select-none">{cell}</span>
                  </button>
                ))}
              </div>

              <div className="mt-4 flex items-center justify-between text-sm text-slate-300">
                <div>turn: <strong className="text-white">{gameOver ? '—' : xIsNext ? 'X' : 'O'}</strong></div>
                <div className="flex gap-2">
                  <button onClick={undo} className="px-3 py-1 rounded-md bg-white/4">undo</button>
                  <button onClick={() => resetBoard(false)} className="px-3 py-1 rounded-md bg-white/4">new round</button>
                </div>
              </div>

              <div className="mt-3 text-center text-slate-200">
                {winner ? <div className="text-lg">ganador: <strong>{winner}</strong></div>
                  : board.every(Boolean) ? <div className="text-lg">empate</div>
                  : null}
              </div>
            </section>

            <aside className="w-40 flex-shrink-0">
              <div className="rounded-xl p-3 bg-white/4 border border-white/6">
                <div className="text-xs text-slate-300">score</div>
                <div className="mt-2 flex flex-col gap-2">
                  <div className="flex justify-between"><span className="text-white">X</span><span className="text-slate-200">{scores.X}</span></div>
                  <div className="flex justify-between"><span className="text-white">O</span><span className="text-slate-200">{scores.O}</span></div>
                  <div className="flex justify-between"><span className="text-white">ties</span><span className="text-slate-200">{scores.ties}</span></div>
                </div>
                <div className="mt-3 text-xs text-slate-300">mode</div>
                <div className="mt-1 flex gap-2">
                  <button onClick={toggleMode} className="flex-1 py-1 rounded-md text-sm bg-white/5">{mode}</button>
                </div>
              </div>

              <div className="mt-4 text-xs text-slate-300">
                <div>accessible, keyboard friendly, responsive</div>
              </div>
            </aside>
          </main>
        </div>
      </div>
    </div>
  )
}


// ---------- helpers ----------
function calculateWinner(squares) {
  const lines = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ]
  for (const [a,b,c] of lines) {
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a]
    }
  }
  return null
}

function isWinningCell(winner, board, idx) {
  if (!winner) return false
  const lines = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ]
  return lines.some(([a,b,c]) => [a,b,c].includes(idx) && board[a] && board[a] === board[b] && board[a] === board[c])
}

// Minimax for optimal CPU (O)
function findBestMove(board) {
  // prefer center, corners heuristically if board empty
  if (board.every(v => v === null)) return 4

  const player = 'O'
  const opponent = 'X'

  function minimax(boardState, isMax) {
    const win = calculateWinner(boardState)
    if (win === player) return { score: 10 }
    if (win === opponent) return { score: -10 }
    if (boardState.every(Boolean)) return { score: 0 }

    const moves = []
    for (let i = 0; i < 9; i++) {
      if (!boardState[i]) {
        const copy = boardState.slice()
        copy[i] = isMax ? player : opponent
        const result = minimax(copy, !isMax)
        moves.push({ index: i, score: result.score })
      }
    }

    if (isMax) {
      let best = moves[0]
      for (const m of moves) if (m.score > best.score) best = m
      return best
    } else {
      let best = moves[0]
      for (const m of moves) if (m.score < best.score) best = m
      return best
    }
  }

  const { index } = minimax(board.slice(), true)
  return index ?? -1
}
